###[./index.html]###

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bread Collector</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="gameContainer">
        <!-- Main Menu -->
        <div id="mainMenu" class="menu-screen">
            <h1 class="game-title">Bread<br>Collector</h1>
            <div id="highScoreDisplay" class="high-score">High Score: 0</div>
            <button class="menu-button" id="startButton">Play</button>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="game-screen hidden">
            <canvas id="gameCanvas"></canvas>
            
            <!-- Health Bar -->
            <div id="healthBarContainer">
                <div id="healthBar">
                    <div id="healthFill"></div>
                </div>
            </div>
            
            <!-- Score Display -->
            <div id="scoreDisplay">Score: 0</div>
            
            <!-- Pause Button -->
            <button id="pauseButton">‚è∏</button>
            
            <!-- Ready/Go Text -->
            <div id="readyText" class="overlay-text hidden"></div>
            
            <!-- Countdown Text -->
            <div id="countdownText" class="overlay-text hidden"></div>
        </div>

        <!-- Pause Modal -->
        <div id="pauseModal" class="modal hidden">
            <div class="modal-content">
                <h2>Paused</h2>
                <button class="menu-button" id="resumeButton">Resume</button>
                <button class="menu-button" id="quitButton">Quit</button>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="gameOverModal" class="modal hidden">
            <div class="modal-content">
                <h2>Game Over</h2>
                <div id="finalScore" class="final-score">Score: 0</div>
                <button class="menu-button" id="tryAgainButton">Try Again</button>
                <button class="menu-button" id="gameOverQuitButton">Quit</button>
            </div>
        </div>
    </div>

    <!-- Scripts (order matters) -->
    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/sprites.js"></script>
    <script src="js/particles.js"></script>
    <script src="js/speedlines.js"></script>
    <script src="js/floatingtext.js"></script>
    <script src="js/damageflash.js"></script>
    <script src="js/actionlines.js"></script>
    <script src="js/bread.js"></script>
    <script src="js/player.js"></script>
    <script src="js/input.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/renderer.js"></script>
    <script src="js/game.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

###EOF###

###[./styles.css]###

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}

html, body {
    width: 100%;
    height: 100dvh;
    overflow: hidden;
    background: #0d0d0d;
    font-family: 'Arial Black', sans-serif;
}

#gameContainer {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    overflow: hidden;
    background: #111;
}

/* Menu Screens */
.menu-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: linear-gradient(180deg, #1f003f 0%, #35004f 50%, #4f0080 100%);
    z-index: 100;
}

.game-title {
    color: #ff6edb;
    font-size: clamp(36px, 10vw, 64px);
    text-align: center;
    margin-bottom: 30px;
    text-shadow: 4px 4px 0 #000, 0 0 20px rgba(255,110,219,0.6);
    letter-spacing: 4px;
}

.high-score {
    color: #ff77ff;
    font-size: clamp(16px, 4vw, 24px);
    margin-bottom: 40px;
    text-shadow: 2px 2px 0 #000;
}

.menu-button {
    width: clamp(180px, 50vw, 260px);
    padding: 15px 30px;
    margin: 10px;
    font-size: clamp(18px, 5vw, 28px);
    font-weight: bold;
    background: linear-gradient(180deg, #ff00ff 0%, #ff77ff 100%);
    color: #fff;
    border: 3px solid #ff6edb;
    border-radius: 0; /* square edges */
    cursor: pointer;
    box-shadow: 0 6px 0 #9c00ff, 0 8px 15px rgba(0,0,0,0.4);
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: transform 0.1s, box-shadow 0.1s;
}

.menu-button:active {
    transform: translateY(4px);
    box-shadow: 0 2px 0 #9c00ff, 0 4px 8px rgba(0,0,0,0.4);
}

/* Game Screen */
.game-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

#gameCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* Health Bar */
#healthBarContainer {
    position: absolute;
    top: 20px;
    left: 20px;
    right: 20px;
    z-index: 10;
}

#healthBar {
    height: 30px;
    background: #2c003d;
    border-radius: 0; /* square */
    overflow: hidden;
    box-shadow: inset 0 4px 8px rgba(255,0,255,0.3), 0 2px 4px rgba(255,0,255,0.2);
}

#healthFill {
    height: 100%;
    width: 50%;
    background: linear-gradient(90deg, #ff00ff, #ff77ff);
    border-radius: 0; /* square */
    transition: width 0.3s ease-out, background 0.3s;
    box-shadow: inset 0 -3px 0 rgba(0,0,0,0.2);
}

#healthFill.limbo {
    background: linear-gradient(90deg, #aa00aa, #bb33bb);
}

#healthFill.normal {
    background: linear-gradient(90deg, #ff00ff, #ff77ff);
}

#healthFill.hyper {
    background: linear-gradient(90deg, #ff6edb, #ff00ff, #ff77ff, #ff33ff, #ff00cc);
    background-size: 200% 100%;
    animation: rainbowShift 1s linear infinite;
}

@keyframes rainbowShift {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
}

/* Score Display */
#scoreDisplay {
    position: absolute;
    top: 60px;
    left: 20px;
    color: #ff77ff;
    font-size: clamp(18px, 5vw, 28px);
    font-weight: bold;
    z-index: 10;
    text-shadow: 2px 2px 4px #000;
}

/* Pause Button */
#pauseButton {
    position: absolute;
    top: 60px;
    right: 20px;
    width: 50px;
    height: 50px;
    font-size: 24px;
    background: rgba(50,0,50,0.7);
    color: #ff77ff;
    border: 2px solid #ff6edb;
    border-radius: 0; /* square edges */
    cursor: pointer;
    z-index: 10;
}

/* Overlay Text */
.overlay-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: clamp(48px, 15vw, 80px);
    color: #ff6edb;
    font-weight: bold;
    z-index: 50;
    text-shadow: 4px 4px 0 #000, 0 0 30px rgba(255,110,219,0.5);
    text-transform: uppercase;
    letter-spacing: 6px;
}

/* Modals */
.modal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(20,0,40,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 200;
}

.modal-content {
    background: linear-gradient(180deg, #330066 0%, #440077 100%);
    padding: 40px;
    border-radius: 0; /* square edges */
    text-align: center;
    box-shadow: 0 10px 40px rgba(255,0,255,0.3);
    border: 2px solid #ff6edb;
}

.modal-content h2 {
    color: #ff77ff;
    font-size: clamp(28px, 8vw, 42px);
    margin-bottom: 20px;
    text-shadow: 2px 2px 0 #000;
}

.final-score {
    color: #ff6edb;
    font-size: clamp(20px, 6vw, 32px);
    margin-bottom: 30px;
    text-shadow: 2px 2px 0 #000;
}

/* Utility Classes */
.hidden {
    display: none !important;
}


###EOF###

###[./js/actionlines.js]###

// ============================================
// ANIME ACTION LINES (Max Health Effect)
// ============================================

const ActionLines = {
    angle: 0,
    lines: [],

    init() {
        this.lines = [];
        for (let i = 0; i < CONFIG.ACTION_LINES_COUNT; i++) {
            this.lines.push({
                angle: (i / CONFIG.ACTION_LINES_COUNT) * Math.PI * 2,
                length: Utils.random(CONFIG.ACTION_LINES_LENGTH_MIN, CONFIG.ACTION_LINES_LENGTH_MAX),
                hue: (i / CONFIG.ACTION_LINES_COUNT) * 360
            });
        }
    },

    update(deltaTime) {
        this.angle += (CONFIG.ACTION_LINES_SPEED * Math.PI / 180) * deltaTime;
        
        // Update hues
        this.lines.forEach(line => {
            line.hue = (line.hue + 180 * deltaTime) % 360;
        });
    },

    draw(ctx, screenWidth, screenHeight) {
        const centerX = screenWidth / 2;
        const centerY = screenHeight / 2;
        const maxDimension = Math.max(screenWidth, screenHeight);

        ctx.save();
        ctx.globalAlpha = CONFIG.ACTION_LINES_OPACITY;
        ctx.lineWidth = CONFIG.ACTION_LINES_THICKNESS;
        ctx.lineCap = 'round';

        this.lines.forEach(line => {
            const angle = line.angle + this.angle;
            const length = line.length * screenHeight;
            
            // Start from edge of screen
            const startDist = maxDimension * 0.7;
            const startX = centerX + Math.cos(angle) * startDist;
            const startY = centerY + Math.sin(angle) * startDist;
            
            // End point (toward center)
            const endX = centerX + Math.cos(angle) * (startDist - length);
            const endY = centerY + Math.sin(angle) * (startDist - length);

            // Rainbow color
            const rgb = Utils.hslToRgb(line.hue, 100, 70);
            ctx.strokeStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        });

        ctx.restore();
    },

    reset() {
        this.angle = 0;
        this.init();
    }
};

###EOF###

###[./js/game.js]###

// ============================================
// GAME STATE & MAIN LOOP
// ============================================

const Game = {
    // State
    running: false,
    paused: false,
    gameOver: false,
    initialized: false,
    
    // Timing
    lastTime: 0,
    gameTime: 0,
    startTime: 0,
    
    // Score & Health
    score: 0,
    health: 0,
    healthState: 1,
    isMaxHealth: false,
    
    // Countdown state
    countdownActive: false,
    countdownValue: 0,
    countdownTime: 0,
    
    // Game over state
    gameOverPauseTime: 0,
    gameOverModalShown: false,

    init() {
        UI.init();
        Renderer.init(document.getElementById('gameCanvas'));
        Input.init(document.getElementById('gameCanvas'));
        ActionLines.init();
        
        // Load sprites then show menu
        Sprites.load(() => {
            this.initialized = true;
            UI.showMainMenu();
        });
    },

    start() {
        this.reset();
        UI.showGameScreen();
        
        // Force clear the canvas before showing Ready
        Renderer.forceClear();
        this.renderClearFrame();
        
        // Show "Ready?"
        UI.showReadyText('Ready?');
        
        setTimeout(() => {
            UI.showReadyText('GO!');
            setTimeout(() => {
                UI.hideReadyText();
                this.running = true;
                this.startTime = performance.now();
                this.lastTime = this.startTime;
                requestAnimationFrame((t) => this.loop(t));
            }, CONFIG.GO_DISPLAY_TIME);
        }, CONFIG.READY_GO_DELAY);
    },

    renderClearFrame() {
        // Render just the background with no game elements
        Renderer.setBackground(this.healthState);
        Renderer.clear();
        Renderer.drawBackground();
    },

    reset() {
        this.running = false;
        this.paused = false;
        this.gameOver = false;
        this.gameTime = 0;
        this.score = 0;
        this.healthState = CONFIG.STARTING_STATE;
        this.health = CONFIG.MAX_HEALTH * CONFIG.STARTING_HEALTH_PCT;
        this.isMaxHealth = false;
        this.countdownActive = false;
        this.gameOverPauseTime = 0;
        this.gameOverModalShown = false;

        const screen = Renderer.getScreen();
        Player.init(screen.width);
        Input.reset(screen.width);
        BreadManager.clear();
        ParticleSystem.clear();
        SpeedLines.clear();
        FloatingTextSystem.clear();
        DamageFlash.reset();
        ActionLines.reset();
        Renderer.resetState();
        Renderer.setBackground(this.healthState);

        UI.updateScore(0);
        UI.updateHealthBar(this.health, CONFIG.MAX_HEALTH, this.healthState, false);
        UI.hideGameOverModal();
        UI.hideCountdown();
    },

    pause() {
        if (this.gameOver) return;
        this.paused = true;
        UI.showPauseModal();
    },

    resume() {
        UI.hidePauseModal();
        this.countdownActive = true;
        this.countdownValue = CONFIG.RESUME_COUNTDOWN_SECONDS;
        this.countdownTime = 0;
        UI.showCountdown(this.countdownValue);
    },

    quit() {
        UI.updateHighScore(this.score);
        this.running = false;
        UI.showMainMenu();
    },

    restart() {
        UI.hideGameOverModal();
        this.start();
    },

    getCurrentSpeed() {
        const elapsed = (performance.now() - this.startTime) / 1000;
        const progress = Math.min(elapsed / CONFIG.SPEED_RAMP_TIME, 1);
        return {
            travelTime: Utils.lerp(CONFIG.BREAD_TRAVEL_TIME, CONFIG.MIN_TRAVEL_TIME, progress),
            spawnInterval: Utils.lerp(CONFIG.INITIAL_SPAWN_INTERVAL, CONFIG.FINAL_SPAWN_INTERVAL, progress),
            animSpeedMult: Utils.lerp(CONFIG.ANIM_SPEED_MULT_START, CONFIG.ANIM_SPEED_MULT_END, progress)
        };
    },

    handleCollision(bread) {
        const screen = Renderer.getScreen();
        const playerStep = Player.getStep(screen);
        const playerInOOB = Player.isInOOB(screen);

        // Get bread position for particles/text
        const breadPos = bread.getScreenPosition(screen);

        // Check collision with margin
        const stepDiff = Math.abs(bread.step - playerStep);
        const isHit = !playerInOOB && stepDiff <= CONFIG.COLLISION_STEP_MARGIN;

        if (isHit) {
            // Collect!
            bread.collect();
            this.score++;
            this.addHealth(CONFIG.HEALTH_GAIN_PER_COLLECT);
            
            // Spawn particles (rainbow if max health)
            ParticleSystem.spawn(breadPos.x, breadPos.y, CONFIG.PARTICLE_COUNT, this.isMaxHealth);
            
            // Spawn text if max health
            if (this.isMaxHealth) {
                FloatingTextSystem.spawnMaxHealthText(Player.x, screen.height * CONFIG.BOTTOM_LINE_Y_PCT);
            }
        } else {
            // Miss!
            bread.miss();
            this.removeHealth(CONFIG.HEALTH_LOSS_PER_MISS);
            Player.triggerDamage();
            DamageFlash.trigger();
            FloatingTextSystem.spawnDamageText(Player.x, screen.height * CONFIG.BOTTOM_LINE_Y_PCT);
        }

        UI.updateScore(this.score);
    },

    addHealth(amount) {
        // Don't add health if already at max
        if (this.isMaxHealth) return;
        
        this.health += amount;
        
        if (this.health >= CONFIG.MAX_HEALTH) {
            if (this.healthState < 2) {
                // Level up
                this.healthState++;
                this.health = this.health - CONFIG.MAX_HEALTH;
                Renderer.setBackground(this.healthState);
                
                // Check if now at max state with full health
                if (this.healthState === 2 && this.health >= CONFIG.MAX_HEALTH) {
                    this.health = CONFIG.MAX_HEALTH;
                    this.isMaxHealth = true;
                }
            } else {
                // At max state - cap health and set max flag
                this.health = CONFIG.MAX_HEALTH;
                this.isMaxHealth = true;
            }
        }
        
        UI.updateHealthBar(this.health, CONFIG.MAX_HEALTH, this.healthState, this.isMaxHealth);
    },

    removeHealth(amount) {
        // If at max health, remove the max flag first
        if (this.isMaxHealth) {
            this.isMaxHealth = false;
        }
        
        this.health -= amount;
        
        if (this.health <= 0) {
            if (this.healthState > 0) {
                // Level down
                this.healthState--;
                this.health = CONFIG.MAX_HEALTH + this.health;
                Renderer.setBackground(this.healthState);
            } else {
                // Game over
                this.health = 0;
                this.triggerGameOver();
            }
        }
        
        UI.updateHealthBar(this.health, CONFIG.MAX_HEALTH, this.healthState, this.isMaxHealth);
    },

    triggerGameOver() {
        this.gameOver = true;
        this.gameOverPauseTime = 0;
        this.gameOverModalShown = false;
        Player.triggerGameOver();
        UI.updateHighScore(this.score);
    },

    update(deltaTime) {
        // Handle countdown
        if (this.countdownActive) {
            this.countdownTime += deltaTime * 1000;
            if (this.countdownTime >= 1000) {
                this.countdownTime -= 1000;
                this.countdownValue--;
                if (this.countdownValue > 0) {
                    UI.showCountdown(this.countdownValue);
                } else {
                    UI.hideCountdown();
                    this.countdownActive = false;
                    this.paused = false;
                }
            }
            return;
        }

        // Handle game over delay
        if (this.gameOver) {
            this.gameOverPauseTime += deltaTime * 1000;
            Player.update(deltaTime);
            FloatingTextSystem.update(deltaTime);
            DamageFlash.update(deltaTime);
            
            if (!this.gameOverModalShown && this.gameOverPauseTime >= CONFIG.GAME_OVER_PAUSE_TIME) {
                this.gameOverModalShown = true;
                UI.showGameOverModal(this.score);
            }
            return;
        }

        if (this.paused) return;

        // Update game time
        this.gameTime += deltaTime;

        // Get current speed
        const speed = this.getCurrentSpeed();

        // Update player input
        Player.setTargetX(Input.getX());
        Player.update(deltaTime);

        // Update bread
        const collisions = BreadManager.update(
            deltaTime, 
            this.gameTime, 
            speed.travelTime, 
            speed.spawnInterval,
            speed.animSpeedMult
        );
        collisions.forEach(bread => this.handleCollision(bread));

        // Update effects
        ParticleSystem.update(deltaTime);
        SpeedLines.update(deltaTime, Renderer.getScreen().width, Renderer.getScreen().height, speed.animSpeedMult, this.healthState);
        FloatingTextSystem.update(deltaTime);
        DamageFlash.update(deltaTime);
        Renderer.updateBackgroundFade(deltaTime);
        Renderer.updateDiscoAnimation(deltaTime);
        Renderer.updateDiscoRainbow(deltaTime, this.isMaxHealth);
        
        if (this.isMaxHealth) {
            Renderer.updateFunnyGifs(deltaTime);
            ActionLines.update(deltaTime);
        }
    },

    loop(timestamp) {
        if (!this.running) return;

        const deltaTime = Math.min((timestamp - this.lastTime) / 1000, 0.1);
        this.lastTime = timestamp;

        this.update(deltaTime);

        Renderer.render({
            healthState: this.healthState,
            isMaxHealth: this.isMaxHealth,
            playerX: Player.x,
            score: this.score,
            health: this.health,
            isPaused: this.paused,
            isGameOver: this.gameOver
        });

        requestAnimationFrame((t) => this.loop(t));
    }
};

###EOF###

###[./js/renderer.js]###

// ============================================
// RENDERING
// ============================================

const Renderer = {
    canvas: null,
    ctx: null,
    screen: { width: 0, height: 0 },
    
    // Background crossfade state
    currentBg: null,
    targetBg: null,
    bgFadeProgress: 1,
    bgFadeTime: 0,
    
    // Disco ball state
    discoFrame: 0,
    discoAnimTime: 0,
    discoFlashOpacity: 0,
    discoFlashTime: 0,
    discoHue: 0,

    // Funny GIF state
    gifFrames: {
        'cat-fu': 0,
        'cheetah': 0,
        'dancing-cat': 0
    },
    gifAnimTimes: {
        'cat-fu': 0,
        'cheetah': 0,
        'dancing-cat': 0
    },

    init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
    },

    resize() {
        const container = document.getElementById('gameContainer');
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // Calculate portrait dimensions
        let gameWidth, gameHeight;
        
        // On mobile (portrait), use full screen
        if (windowWidth < windowHeight) {
            gameWidth = windowWidth;
            gameHeight = windowHeight;
        } else {
            // On desktop/landscape, constrain to portrait aspect ratio
            gameHeight = windowHeight;
            gameWidth = Math.min(gameHeight * CONFIG.PORTRAIT_ASPECT_RATIO, CONFIG.MAX_GAME_WIDTH);
        }
        
        // Apply dimensions to container
        container.style.width = `${gameWidth}px`;
        container.style.height = `${gameHeight}px`;
        
        // Set canvas dimensions
        this.canvas.width = gameWidth;
        this.canvas.height = gameHeight;
        this.screen = {
            width: gameWidth,
            height: gameHeight
        };
    },

    getScreen() {
        return this.screen;
    },

    setBackground(healthState) {
        let newBg;
        switch (healthState) {
            case 0: newBg = 'bg-limbo'; break;
            case 2: newBg = 'bg-hyper'; break;
            default: newBg = 'bg-normal';
        }

        if (newBg !== this.targetBg) {
            this.currentBg = this.targetBg || newBg;
            this.targetBg = newBg;
            this.bgFadeProgress = 0;
            this.bgFadeTime = 0;
            
            // Trigger disco ball flash
            this.discoFlashOpacity = CONFIG.DISCO_FLASH_OPACITY;
            this.discoFlashTime = 0;
        }
    },

    updateBackgroundFade(deltaTime) {
        if (this.bgFadeProgress < 1) {
            this.bgFadeTime += deltaTime * 1000;
            this.bgFadeProgress = Math.min(this.bgFadeTime / CONFIG.BG_CROSSFADE_TIME, 1);
        }
        
        // Update disco flash
        if (this.discoFlashOpacity > 0) {
            this.discoFlashTime += deltaTime * 1000;
            this.discoFlashOpacity = CONFIG.DISCO_FLASH_OPACITY * 
                (1 - this.discoFlashTime / CONFIG.DISCO_FLASH_FADE_TIME);
            if (this.discoFlashOpacity < 0) this.discoFlashOpacity = 0;
        }
    },

    updateDiscoRainbow(deltaTime, isMaxHealth) {
        if (isMaxHealth) {
            this.discoHue = (this.discoHue + CONFIG.DISCO_RAINBOW_SPEED * deltaTime) % 360;
        }
    },

    drawBackground() {
        const ctx = this.ctx;
        const { width, height } = this.screen;

        // Draw current background
        if (this.currentBg) {
            const img = Sprites.get(this.currentBg);
            if (img) {
                ctx.globalAlpha = 1 - this.bgFadeProgress;
                ctx.drawImage(img, 0, 0, width, height);
            }
        }

        // Draw target background
        if (this.targetBg) {
            const img = Sprites.get(this.targetBg);
            if (img) {
                ctx.globalAlpha = this.bgFadeProgress;
                ctx.drawImage(img, 0, 0, width, height);
            }
        }

        ctx.globalAlpha = 1;
    },

    updateDiscoAnimation(deltaTime) {
        this.discoAnimTime += deltaTime;
        const frameTime = 1 / CONFIG.DISCO_ANIM_FPS;
        if (this.discoAnimTime >= frameTime) {
            this.discoAnimTime -= frameTime;
            this.discoFrame += CONFIG.DISCO_ANIM_DIRECTION;
            if (this.discoFrame >= CONFIG.DISCO_TOTAL_FRAMES) {
                this.discoFrame = 0;
            } else if (this.discoFrame < 0) {
                this.discoFrame = CONFIG.DISCO_TOTAL_FRAMES - 1;
            }
        }
    },

    drawDiscoBall(playerX, healthState, isMaxHealth) {
        const ctx = this.ctx;
        const { height } = this.screen;
        
        const x = playerX + CONFIG.DISCO_OFFSET_X;
        const y = height - (height * CONFIG.DISCO_OFFSET_Y_PCT);

        let spriteName;
        switch (healthState) {
            case 0: spriteName = 'disco-ball-limbo'; break;
            case 2: spriteName = 'disco-ball-hyper'; break;
            default: spriteName = 'disco-ball-normal';
        }

        const img = Sprites.get(spriteName);
        if (!img) return { x, y };

        const frameWidth = img.width / CONFIG.DISCO_COLS;
        const frameHeight = img.height / CONFIG.DISCO_ROWS;
        const col = this.discoFrame % CONFIG.DISCO_COLS;
        const row = Math.floor(this.discoFrame / CONFIG.DISCO_COLS);

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(CONFIG.DISCO_ROTATION_DEG * Math.PI / 180);

        // Apply rainbow hue rotation if max health
        if (isMaxHealth) {
            ctx.filter = `hue-rotate(${this.discoHue}deg)`;
        }

        ctx.drawImage(
            img,
            col * frameWidth, row * frameHeight,
            frameWidth, frameHeight,
            -frameWidth * CONFIG.DISCO_SCALE / 2, -frameHeight * CONFIG.DISCO_SCALE / 2,
            frameWidth * CONFIG.DISCO_SCALE, frameHeight * CONFIG.DISCO_SCALE
        );

        ctx.restore();

        return { x, y };
    },

    updateFunnyGifs(deltaTime) {
        const gifs = [
            { key: 'cat-fu', config: CONFIG.GIF_CAT_FU },
            { key: 'cheetah', config: CONFIG.GIF_CHEETAH },
            { key: 'dancing-cat', config: CONFIG.GIF_DANCING_CAT }
        ];

        gifs.forEach(gif => {
            this.gifAnimTimes[gif.key] += deltaTime;
            const frameTime = 1 / gif.config.fps;
            if (this.gifAnimTimes[gif.key] >= frameTime) {
                this.gifAnimTimes[gif.key] -= frameTime;
                this.gifFrames[gif.key] = (this.gifFrames[gif.key] + 1) % gif.config.frames;
            }
        });
    },

    drawFunnyGifs() {
        const ctx = this.ctx;
        const { width, height } = this.screen;

        const gifs = [
            { key: 'cat-fu', sprite: 'gif-cat-fu', config: CONFIG.GIF_CAT_FU },
            { key: 'cheetah', sprite: 'gif-cheetah', config: CONFIG.GIF_CHEETAH },
            { key: 'dancing-cat', sprite: 'gif-dancing-cat', config: CONFIG.GIF_DANCING_CAT }
        ];

        gifs.forEach(gif => {
            const x = width * gif.config.x;
            const y = height * (1 - gif.config.y);

            Sprites.drawFrame(
                ctx,
                gif.sprite,
                this.gifFrames[gif.key],
                x, y,
                gif.config.cols, gif.config.rows,
                gif.config.scale
            );
        });
    },

    drawDebugInfo(screen, playerStep, playerX, playerInOOB) {
        if (!CONFIG.DEBUG_MODE) return;

        const ctx = this.ctx;
        const stepBoundaries = Utils.getStepBoundaries(screen);
        const collisionY = screen.height * CONFIG.BOTTOM_LINE_Y_PCT;

        ctx.save();
        
        // Draw collision line
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, collisionY);
        ctx.lineTo(screen.width, collisionY);
        ctx.stroke();

        // Draw step boundaries at collision line
        stepBoundaries.forEach((step, i) => {
            // Draw step box
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(step.left, collisionY - 20, step.right - step.left, 40);
            
            // Highlight player step and margin steps
            const margin = CONFIG.COLLISION_STEP_MARGIN;
            if (i >= playerStep - margin && i <= playerStep + margin && !playerInOOB) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(step.left, collisionY - 20, step.right - step.left, 40);
            }
            
            // Draw step number
            ctx.fillStyle = 'red';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(i.toString(), step.center, collisionY + 35);
        });

        // Draw bread centers at collision line
        BreadManager.breads.forEach(bread => {
            if (bread.z >= 0.9) {
                const pos = bread.getScreenPosition(screen);
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // Draw player position indicator
        ctx.fillStyle = playerInOOB ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 255, 0, 0.8)';
        ctx.beginPath();
        ctx.arc(playerX, collisionY, 8, 0, Math.PI * 2);
        ctx.fill();

        // Draw OOB zones
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
        ctx.fillRect(0, 0, marginX, screen.height);
        ctx.fillRect(screen.width - marginX, 0, marginX, screen.height);

        ctx.restore();
    },

    clear() {
        this.ctx.clearRect(0, 0, this.screen.width, this.screen.height);
    },

    render(gameState) {
        this.clear();

        const { healthState, isMaxHealth, playerX, isPaused, isGameOver } = gameState;

        // Draw background
        this.drawBackground();

        // Draw funny GIFs if at max health
        if (isMaxHealth) {
            this.drawFunnyGifs();
        }

        // Draw action lines if at max health
        if (isMaxHealth) {
            ActionLines.draw(this.ctx, this.screen.width, this.screen.height);
        }

        // Draw speed lines
        SpeedLines.draw(this.ctx, this.screen.width, this.screen.height, healthState);

        // Draw breads
        BreadManager.draw(this.ctx, this.screen, healthState);

        // Draw disco ball and get position
        const discoPos = this.drawDiscoBall(playerX, healthState, isMaxHealth);

        // Draw player
        Player.draw(this.ctx, this.screen, healthState, discoPos.x, discoPos.y);

        // Draw particles
        ParticleSystem.draw(this.ctx);

        // Draw floating text
        FloatingTextSystem.draw(this.ctx);

        // Draw damage flash
        DamageFlash.draw(this.ctx, this.screen.width, this.screen.height);

        // Draw debug info
        const playerStep = Player.getStep(this.screen);
        const playerInOOB = Player.isInOOB(this.screen);
        this.drawDebugInfo(this.screen, playerStep, playerX, playerInOOB);
    },

    resetState() {
        this.currentBg = null;
        this.targetBg = null;
        this.bgFadeProgress = 1;
        this.discoFrame = 0;
        this.discoFlashOpacity = 0;
        this.discoHue = 0;
        
        Object.keys(this.gifFrames).forEach(key => {
            this.gifFrames[key] = 0;
            this.gifAnimTimes[key] = 0;
        });
    },

    // Force clear everything (for game reset)
    forceClear() {
        this.clear();
        this.resetState();
    }
};

###EOF###

###[./js/ui.js]###

// ============================================
// UI MANAGEMENT
// ============================================

const UI = {
    elements: {},
    highScore: 0,
    tiltEnabled: false, // Tracks whether tilt is active

    init() {
        this.elements = {
            mainMenu: document.getElementById('mainMenu'),
            gameScreen: document.getElementById('gameScreen'),
            pauseModal: document.getElementById('pauseModal'),
            gameOverModal: document.getElementById('gameOverModal'),
            healthFill: document.getElementById('healthFill'),
            scoreDisplay: document.getElementById('scoreDisplay'),
            highScoreDisplay: document.getElementById('highScoreDisplay'),
            readyText: document.getElementById('readyText'),
            countdownText: document.getElementById('countdownText'),
            finalScore: document.getElementById('finalScore'),
            startButton: document.getElementById('startButton'),
            pauseButton: document.getElementById('pauseButton'),
            resumeButton: document.getElementById('resumeButton'),
            quitButton: document.getElementById('quitButton'),
            tryAgainButton: document.getElementById('tryAgainButton'),
            gameOverQuitButton: document.getElementById('gameOverQuitButton')
        };

        // Load high score
        this.highScore = parseInt(localStorage.getItem('breadHighScore')) || 0;
        this.updateHighScoreDisplay();

        // Setup button handlers
        this.setupButtons();

        // Show initial tilt dialogue
        this.showTiltDialog();
    },

    setupButtons() {
        this.elements.startButton.addEventListener('click', () => {
            Game.start();
        });
        this.elements.pauseButton.addEventListener('click', () => Game.pause());
        this.elements.resumeButton.addEventListener('click', () => Game.resume());
        this.elements.quitButton.addEventListener('click', () => Game.quit());
        this.elements.tryAgainButton.addEventListener('click', () => Game.restart());
        this.elements.gameOverQuitButton.addEventListener('click', () => Game.quit());
    },

    // =============================
    // Tilt Dialog
    // =============================
    showTiltDialog() {
        // Create overlay
        const overlay = document.createElement('div');
        overlay.id = 'tiltDialog';
        overlay.className = 'modal';
        overlay.style.background = 'rgba(0,0,0,0.9)';
        overlay.style.zIndex = 300;

        // Content box
        const box = document.createElement('div');
        box.className = 'modal-content';
        box.style.borderRadius = '0'; // Bauhaus square edges
        box.style.background = 'linear-gradient(180deg, #ff77ff, #77ffff)';
        box.style.padding = '30px';
        box.style.textAlign = 'center';

        const title = document.createElement('h2');
        title.textContent = 'Enable Tilt Controls?';
        title.style.color = '#fff';
        title.style.marginBottom = '20px';
        title.style.fontFamily = "'Arial Black', sans-serif";
        box.appendChild(title);

        const button = document.createElement('button');
        button.textContent = 'Enable Tilt';
        button.className = 'menu-button';
        button.style.borderRadius = '0';
        button.style.background = 'linear-gradient(180deg, #ff88ff, #88ffcc)';
        button.style.color = '#000';
        button.style.fontWeight = 'bold';
        button.style.fontSize = 'clamp(18px,5vw,28px)';
        button.addEventListener('click', () => {
            Input.enableTilt();
            this.tiltEnabled = true;
            overlay.remove();
        });
        box.appendChild(button);

        overlay.appendChild(box);
        document.body.appendChild(overlay);
    },

    // =============================
    // Existing functions (menus, score, health)
    // =============================
    showMainMenu() {
        this.elements.mainMenu.classList.remove('hidden');
        this.elements.gameScreen.classList.add('hidden');
        this.elements.pauseModal.classList.add('hidden');
        this.elements.gameOverModal.classList.add('hidden');
        this.updateHighScoreDisplay();
    },

    showGameScreen() {
        this.elements.mainMenu.classList.add('hidden');
        this.elements.gameScreen.classList.remove('hidden');
        this.elements.pauseModal.classList.add('hidden');
        this.elements.gameOverModal.classList.add('hidden');
    },

    showPauseModal() {
        this.elements.pauseModal.classList.remove('hidden');
    },

    hidePauseModal() {
        this.elements.pauseModal.classList.add('hidden');
    },

    showGameOverModal(score) {
        this.elements.finalScore.textContent = `Score: ${score}`;
        this.elements.gameOverModal.classList.remove('hidden');
    },

    hideGameOverModal() {
        this.elements.gameOverModal.classList.add('hidden');
    },

    showReadyText(text) {
        this.elements.readyText.textContent = text;
        this.elements.readyText.classList.remove('hidden');
    },

    hideReadyText() {
        this.elements.readyText.classList.add('hidden');
    },

    showCountdown(number) {
        this.elements.countdownText.textContent = number;
        this.elements.countdownText.classList.remove('hidden');
    },

    hideCountdown() {
        this.elements.countdownText.classList.add('hidden');
    },

    updateScore(score) {
        this.elements.scoreDisplay.textContent = `Score: ${score}`;
    },

    updateHealthBar(health, maxHealth, healthState, isMaxed) {
        const percentage = isMaxed ? 100 : (health / maxHealth) * 100;
        this.elements.healthFill.style.width = `${percentage}%`;
        this.elements.healthFill.classList.remove('limbo', 'normal', 'hyper');
        switch (healthState) {
            case 0: this.elements.healthFill.classList.add('limbo'); break;
            case 1: this.elements.healthFill.classList.add('normal'); break;
            case 2: this.elements.healthFill.classList.add('hyper'); break;
        }
    },

    updateHighScore(score) {
        if (score > this.highScore) {
            this.highScore = score;
            localStorage.setItem('breadHighScore', this.highScore);
        }
    },

    updateHighScoreDisplay() {
        this.elements.highScoreDisplay.textContent = `High Score: ${this.highScore}`;
    }
};


###EOF###

###[./js/speedlines.js]###

// ============================================
// SPEED LINES OVERLAY EFFECT
// ============================================

class SpeedLine {
    constructor(y, screenHeight) {
        this.y = y;
        this.screenHeight = screenHeight;
        this.startY = y;
        this.alive = true;
    }

    update(deltaTime, speed, animSpeedMult) {
        // Accelerate as it moves down
        const progress = (this.y - this.startY) / (this.screenHeight - this.startY);
        const acceleration = Math.pow(progress + 0.1, CONFIG.SPEEDLINE_ACCEL_POWER);
        this.y += speed * acceleration * deltaTime * animSpeedMult;

        // Die when off screen
        if (this.y > this.screenHeight) {
            this.alive = false;
        }
    }

    draw(ctx, screenWidth, screenHeight, healthState) {
        if (!this.alive) return;

        // Get state-specific colors
        let colorConfig;
        switch (healthState) {
            case 0: colorConfig = CONFIG.SPEEDLINE_LIMBO; break;
            case 2: colorConfig = CONFIG.SPEEDLINE_HYPER; break;
            default: colorConfig = CONFIG.SPEEDLINE_NORMAL;
        }

        // Calculate progress (0 at spawn, 1 at bottom)
        const totalDistance = screenHeight - this.startY;
        const traveled = this.y - this.startY;
        const progress = Utils.clamp(traveled / totalDistance, 0, 1);

        // Interpolate color
        const r = Utils.lerp(colorConfig.startColor[0], colorConfig.endColor[0], progress);
        const g = Utils.lerp(colorConfig.startColor[1], colorConfig.endColor[1], progress);
        const b = Utils.lerp(colorConfig.startColor[2], colorConfig.endColor[2], progress);
        const alpha = Utils.lerp(colorConfig.startOpacity, colorConfig.endOpacity, progress);

        // Interpolate thickness
        const thickness = Utils.lerp(CONFIG.SPEEDLINE_INITIAL_THICKNESS, CONFIG.SPEEDLINE_FINAL_THICKNESS, progress);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter'; // Additive blend
        ctx.strokeStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
        ctx.lineWidth = thickness;
        ctx.beginPath();
        ctx.moveTo(0, this.y);
        ctx.lineTo(screenWidth, this.y);
        ctx.stroke();
        ctx.restore();
    }
}

const SpeedLines = {
    lines: [],
    lastSpawnY: 0,
    initialized: false,

    init(screenHeight) {
        this.lines = [];
        this.lastSpawnY = screenHeight * (1 - CONFIG.SPEEDLINE_SPAWN_Y_PCT);
        this.initialized = true;
    },

    update(deltaTime, screenWidth, screenHeight, animSpeedMult, healthState) {
        if (!this.initialized) {
            this.init(screenHeight);
        }

        const speed = CONFIG.SPEEDLINE_BASE_SPEED;
        const spawnY = screenHeight * (1 - CONFIG.SPEEDLINE_SPAWN_Y_PCT);

        // Update existing lines
        for (let i = this.lines.length - 1; i >= 0; i--) {
            this.lines[i].update(deltaTime, speed, animSpeedMult);
            if (!this.lines[i].alive) {
                this.lines.splice(i, 1);
            }
        }

        // Check if we need to spawn a new line
        let highestLineY = screenHeight;
        this.lines.forEach(line => {
            if (line.y < highestLineY) {
                highestLineY = line.y;
            }
        });

        // Spawn new line if the highest one has moved enough
        if (highestLineY > spawnY + CONFIG.SPEEDLINE_SPAWN_DISTANCE || this.lines.length === 0) {
            this.lines.push(new SpeedLine(spawnY, screenHeight));
        }
    },

    draw(ctx, screenWidth, screenHeight, healthState) {
        this.lines.forEach(line => line.draw(ctx, screenWidth, screenHeight, healthState));
    },

    clear() {
        this.lines = [];
        this.initialized = false;
    }
};

###EOF###

###[./js/damageflash.js]###

// ============================================
// DAMAGE FLASH EFFECT
// ============================================

const DamageFlash = {
    active: false,
    time: 0,
    duration: CONFIG.DAMAGE_FLASH_DURATION,

    trigger() {
        this.active = true;
        this.time = 0;
    },

    update(deltaTime) {
        if (!this.active) return;
        
        this.time += deltaTime * 1000;
        if (this.time >= this.duration) {
            this.active = false;
        }
    },

    draw(ctx, screenWidth, screenHeight) {
        if (!this.active) return;

        const progress = this.time / this.duration;
        const currentOpacity = Utils.lerp(CONFIG.DAMAGE_FLASH_MAX_OPACITY, 0, progress);
        
        if (currentOpacity <= 0) return;

        const gradientHeight = screenHeight * CONFIG.DAMAGE_FLASH_HEIGHT_PCT;
        const gradientY = screenHeight - gradientHeight;

        const gradient = ctx.createLinearGradient(0, screenHeight, 0, gradientY);
        const [r, g, b] = CONFIG.DAMAGE_FLASH_COLOR;
        
        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${currentOpacity})`);
        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${CONFIG.DAMAGE_FLASH_MIN_OPACITY * currentOpacity})`);

        ctx.save();
        ctx.fillStyle = gradient;
        ctx.fillRect(0, gradientY, screenWidth, gradientHeight);
        ctx.restore();
    },

    reset() {
        this.active = false;
        this.time = 0;
    }
};

###EOF###

###[./js/config.js]###

// ============================================
// CONFIGURATION - All DEF parameters
// ============================================

const CONFIG = {
    // ==========================================
    // DEBUG MODE
    // ==========================================
    DEBUG_MODE: false,                  // DEF: Toggle to show hitboxes and collision info
    
    // ==========================================
    // SCREEN & PLAY FIELD
    // ==========================================
    OOB_MARGIN_PERCENT: 0.07,          // DEF: Out of bounds zone on each side (%)
    NUM_STEPS: 14,                      // DEF: Number of quantized bread positions
    PORTRAIT_ASPECT_RATIO: 9 / 16,      // DEF: Aspect ratio for portrait mode (width/height)
    MAX_GAME_WIDTH: 450,                // DEF: Maximum game width on desktop
    
    // ==========================================
    // TOP LINE (FAR) - Where bread spawns
    // ==========================================
    TOP_LINE_WIDTH_PCT: 0.35,           // DEF: Width of top line as % of screen width
    TOP_LINE_Y_PCT: 0,                  // DEF: Top line position from top (% of height)
    
    // ==========================================
    // BOTTOM LINE (CLOSE) - Where collision happens
    // ==========================================
    BOTTOM_LINE_Y_PCT: 0.82,            // DEF: Bottom line position from top (% of height)
    
    // ==========================================
    // DEPTH SCALE (z-based sprite scaling)
    // ==========================================
    SCALE_FAR: 0.25,                    // DEF: Scale at z=0 (far)
    SCALE_NEAR: 1.0,                    // DEF: Scale at z=1 (near)
    SCALE_POWER: 1.8,                   // DEF: Power for scale easing curve
    
    // ==========================================
    // MOVEMENT EASING
    // ==========================================
    Z_EASE_POWER: 2.2,                  // DEF: Easing power for z movement (higher = more acceleration toward player)
    BREAD_TRAVEL_TIME: 5.0,             // DEF: Base time for bread to travel from top to bottom (seconds)
    MIN_TRAVEL_TIME: 0.8,               // DEF: Minimum travel time at max speed
    
    // ==========================================
    // COLLISION
    // ==========================================
    COLLISION_Z: 1.0,                   // DEF: z value at which collision is checked
    COLLISION_STEP_MARGIN: 1,           // DEF: Number of steps margin on each side for collision (0 = exact match only)
    
    // ==========================================
    // GAME SPEED
    // ==========================================
    INITIAL_SPAWN_INTERVAL: 1.2,        // DEF: Initial seconds between bread spawns
    FINAL_SPAWN_INTERVAL: 0.4,          // DEF: Final seconds between bread spawns
    SPEED_RAMP_TIME: 60,                // DEF: Seconds to reach max speed
    
    // ==========================================
    // ANIMATION SPEED MULTIPLIER (applies to bread, speed lines, NOT player/disco)
    // ==========================================
    ANIM_SPEED_MULT_START: 1.0,         // DEF: Animation speed multiplier at game start
    ANIM_SPEED_MULT_END: 1.8,           // DEF: Animation speed multiplier at max speed
    
    // ==========================================
    // HEALTH SYSTEM
    // ==========================================
    MAX_HEALTH: 300,                    // DEF: Max health per state
    HEALTH_LOSS_PER_MISS: 100,          // DEF: Health lost when missing bread
    HEALTH_GAIN_PER_COLLECT: 50,        // DEF: Health gained when collecting bread
    
    // ==========================================
    // HEALTH STATES
    // ==========================================
    // 0 = limbo (gray), 1 = normal, 2 = hyper (max/rainbow)
    STARTING_STATE: 1,
    STARTING_HEALTH_PCT: 0.5,           // DEF: Starting health as % of max
    
    // ==========================================
    // BACKGROUND
    // ==========================================
    BG_CROSSFADE_TIME: 400,             // DEF: Crossfade duration in ms
    
    // ==========================================
    // SPEED LINES OVERLAY - PER STATE COLORS
    // ==========================================
    SPEEDLINE_SPAWN_Y_PCT: 0.589,       // DEF: % from bottom where lines spawn
    SPEEDLINE_INITIAL_THICKNESS: 1.5,   // DEF: Thickness at spawn
    SPEEDLINE_FINAL_THICKNESS: 6,       // DEF: Thickness at bottom
    SPEEDLINE_SPAWN_DISTANCE: 8,        // DEF: Pixels traveled before spawning new line
    SPEEDLINE_ACCEL_POWER: 1.6,         // DEF: Acceleration power (higher = faster at bottom)
    SPEEDLINE_BASE_SPEED: 800,          // DEF: Base speed in pixels/second
    
    // State-specific speed line colors
    SPEEDLINE_LIMBO: {
        startColor: [150, 150, 150],
        startOpacity: 0.3,
        endColor: [100, 100, 100],
        endOpacity: 0.6
    },
    SPEEDLINE_NORMAL: {
        startColor: [255, 255, 255],
        startOpacity: 0.5,
        endColor: [200, 220, 255],
        endOpacity: 1.0
    },
    SPEEDLINE_HYPER: {
        startColor: [255, 100, 100],
        startOpacity: 0.6,
        endColor: [255, 50, 255],
        endOpacity: 1.0
    },
    
    // ==========================================
    // BREAD SPRITES
    // ==========================================
    BREAD_TOTAL_FRAMES: 13,             // DEF: Total animation frames
    BREAD_COLS: 5,                      // DEF: Spritesheet columns
    BREAD_ROWS: 3,                      // DEF: Spritesheet rows
    BREAD_ANIM_FPS: 14,                 // DEF: Normal animation speed
    BREAD_MISS_ANIM_FPS: 28,            // DEF: Animation speed when missed
    BREAD_SHAKE_TIME: 250,              // DEF: Shake duration in ms
    BREAD_SHAKE_INTENSITY: 8,           // DEF: Shake intensity in pixels
    
    // ==========================================
    // DISCO BALL
    // ==========================================
    DISCO_ROTATION_DEG: 90,             // DEF: Rotation angle in degrees
    DISCO_OFFSET_X: 0,                  // DEF: X offset from player position
    DISCO_OFFSET_Y_PCT: 0.13,           // DEF: Y offset as % of screen height (from bottom)
    DISCO_COLS: 4,                      // DEF: Spritesheet columns
    DISCO_ROWS: 3,                      // DEF: Spritesheet rows
    DISCO_TOTAL_FRAMES: 12,             // DEF: Total frames
    DISCO_ANIM_FPS: 24,                 // DEF: Animation speed
    DISCO_ANIM_DIRECTION: 1,            // DEF: 1 = forward, -1 = backward
    DISCO_FLASH_OPACITY: 0.85,          // DEF: Flash opacity on state change
    DISCO_FLASH_FADE_TIME: 350,         // DEF: Flash fade duration in ms
    DISCO_SCALE: 0.4,                   // DEF: Base scale of disco ball
    DISCO_RAINBOW_SPEED: 180,           // DEF: Hue rotation speed (degrees/second) during max health
    
    // ==========================================
    // PLAYER SPRITES
    // ==========================================
    PLAYER_UNIVERSAL_OFFSET_X: 0,       // DEF: Universal X offset
    PLAYER_UNIVERSAL_OFFSET_Y_PCT: -0.22, // DEF: Universal Y offset as % of height
    
    // Individual sprite offsets (relative to disco ball + universal)
    PLAYER_RUN_OFFSET_X: 0,             // DEF
    PLAYER_RUN_OFFSET_Y: 60,            // DEF
    PLAYER_RUN_FRAMES: 8,               // DEF
    PLAYER_RUN_FPS: 12,                 // DEF
    
    PLAYER_DAMAGE_HOLD_OFFSET_X: 0,     // DEF
    PLAYER_DAMAGE_HOLD_OFFSET_Y: 60,    // DEF
    PLAYER_DAMAGE_HOLD_FRAMES: 8,       // DEF
    PLAYER_DAMAGE_HOLD_FPS: 14,         // DEF
    PLAYER_DAMAGE_HOLD_LOOPS: 2,        // DEF: Number of loops before switching to recover
    
    PLAYER_DAMAGE_RECOVER_OFFSET_X: 0,  // DEF
    PLAYER_DAMAGE_RECOVER_OFFSET_Y: 60, // DEF
    PLAYER_DAMAGE_RECOVER_FRAMES: 8,    // DEF
    PLAYER_DAMAGE_RECOVER_FPS: 14,      // DEF
    
    PLAYER_DEFEAT_KNEE_OFFSET_X: 0,     // DEF
    PLAYER_DEFEAT_KNEE_OFFSET_Y: 60,    // DEF
    PLAYER_DEFEAT_KNEE_FRAMES: 11,      // DEF
    PLAYER_DEFEAT_KNEE_FPS: 10,         // DEF
    
    PLAYER_SCALE: 0.8,                  // DEF: Base scale of player sprite
    
    // ==========================================
    // FUNNY GIFS (shown at max health)
    // ==========================================
    GIF_CAT_FU: {
        x: 0.12,
        y: 0.45,
        cols: 5,
        rows: 4,
        frames: 20,
        fps: 15,
        scale: 0.7
    },
    GIF_CHEETAH: {
        x: 0.5,
        y: 0.35,
        cols: 2,
        rows: 3,
        frames: 6,
        fps: 10,
        scale: 0.8
    },
    GIF_DANCING_CAT: {
        x: 0.85,
        y: 0.45,
        cols: 6,
        rows: 3,
        frames: 18,
        fps: 12,
        scale: 0.7
    },
    
    // ==========================================
    // ANIME ACTION LINES (max health effect)
    // ==========================================
    ACTION_LINES_COUNT: 24,             // DEF: Number of action lines around viewport
    ACTION_LINES_LENGTH_MIN: 0.08,      // DEF: Min length as % of screen height
    ACTION_LINES_LENGTH_MAX: 0.18,      // DEF: Max length as % of screen height
    ACTION_LINES_THICKNESS: 3,          // DEF: Line thickness
    ACTION_LINES_SPEED: 400,            // DEF: Animation speed (degrees/second)
    ACTION_LINES_OPACITY: 0.9,          // DEF: Line opacity
    
    // ==========================================
    // PARTICLES
    // ==========================================
    PARTICLE_COUNT: 12,                 // DEF: Particles on bread collect
    PARTICLE_SPEED_MIN: 100,            // DEF: Min particle speed
    PARTICLE_SPEED_MAX: 250,            // DEF: Max particle speed
    PARTICLE_LIFETIME: 0.6,             // DEF: Particle lifetime in seconds
    PARTICLE_SIZE_MIN: 4,               // DEF: Min particle size
    PARTICLE_SIZE_MAX: 10,              // DEF: Max particle size
    PARTICLE_COLORS: ['#FFD700', '#FFA500', '#FF6347', '#FFFF00'],
    PARTICLE_RAINBOW_COLORS: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#8B00FF', '#FF00FF'],
    
    // ==========================================
    // DAMAGE FLASH EFFECT
    // ==========================================
    DAMAGE_FLASH_COLOR: [255, 0, 0],    // DEF: RGB color for damage flash
    DAMAGE_FLASH_MAX_OPACITY: 0.5,      // DEF: Maximum opacity at bottom
    DAMAGE_FLASH_MIN_OPACITY: 0.0,      // DEF: Minimum opacity at top of gradient
    DAMAGE_FLASH_HEIGHT_PCT: 0.4,       // DEF: How far up the gradient goes (% of screen)
    DAMAGE_FLASH_DURATION: 400,         // DEF: Duration of flash in ms
    
    // ==========================================
    // FLOATING TEXT
    // ==========================================
    // Damage text
    FLOAT_TEXT_DAMAGE_TEXTS: ['OUCH!', 'YIKES!', 'OOF!', 'NO!', 'MISS!'],
    FLOAT_TEXT_DAMAGE_COLOR: '#FF4444',
    FLOAT_TEXT_DAMAGE_FONT_SIZE: 32,
    FLOAT_TEXT_DAMAGE_RISE_DISTANCE: 80,
    FLOAT_TEXT_DAMAGE_DURATION: 800,
    FLOAT_TEXT_DAMAGE_OFFSET_Y: -50,    // DEF: Spawn offset from player position
    
    // Max health text
    FLOAT_TEXT_MAX_TEXTS: ['BREAD!', 'WOW!', 'AMAZING!', 'YUMMY!', 'EPIC!', 'NICE!'],
    FLOAT_TEXT_MAX_FONT_SIZE: 36,
    FLOAT_TEXT_MAX_RISE_DISTANCE: 100,
    FLOAT_TEXT_MAX_DURATION: 1000,
    FLOAT_TEXT_MAX_OFFSET_Y: -60,
    FLOAT_TEXT_MAX_RAINBOW_SPEED: 360,  // DEF: Hue rotation speed for rainbow text
    
    // ==========================================
    // UI & TIMING
    // ==========================================
    GAME_OVER_PAUSE_TIME: 2500,         // DEF: Pause before showing game over modal (ms)
    RESUME_COUNTDOWN_SECONDS: 3,        // DEF: Countdown seconds before resume
    READY_GO_DELAY: 1000,               // DEF: Time showing "Ready?" (ms)
    GO_DISPLAY_TIME: 500,               // DEF: Time showing "GO!" (ms)
};

###EOF###

###[./js/main.js]###

// ============================================
// ENTRY POINT
// ============================================

window.addEventListener('DOMContentLoaded', () => {
    Game.init();
});

###EOF###

###[./js/sprites.js]###

// ============================================
// SPRITE MANAGEMENT
// ============================================

const Sprites = {
    images: {},
    loaded: false,
    loadCount: 0,
    totalCount: 0,

    manifest: {
        // Backgrounds
        'bg-limbo': 'assets/bg-limbo.png',
        'bg-normal': 'assets/bg-normal.png',
        'bg-hyper': 'assets/bg-hyper.png',
        
        // Bread spritesheets
        'bread-limbo': 'assets/bread-limbo-3x5.png',
        'bread-normal': 'assets/bread-normal-3x5.png',
        'bread-hyper': 'assets/bread-hyper-3x5.png',
        
        // Disco ball spritesheets
        'disco-ball-limbo': 'assets/disco-ball-limbo-3x4.png',
        'disco-ball-normal': 'assets/disco-ball-normal-3x4.png',
        'disco-ball-hyper': 'assets/disco-ball-hyper-3x4.png',
        
        // Funny GIFs
        'gif-cat-fu': 'assets/gif-cat-fu-4x5.png',
        'gif-cheetah': 'assets/gif-cheetah-3x2.png',
        'gif-dancing-cat': 'assets/gif-dancing-cat-3x6.png',
        
        // Player spritesheets
        'player-run': 'assets/player-run-1x8.png',
        'player-damage-hold': 'assets/player-damage-hold-1x8.png',
        'player-damage-recover': 'assets/player-damage-recover-1x8.png',
        'player-defeat-knee': 'assets/player-defeat-knee-1x11.png'
    },

    load(onComplete) {
        const keys = Object.keys(this.manifest);
        this.totalCount = keys.length;
        this.loadCount = 0;

        if (keys.length === 0) {
            this.loaded = true;
            onComplete && onComplete();
            return;
        }

        keys.forEach(key => {
            const img = new Image();
            img.onload = () => {
                this.images[key] = img;
                this.loadCount++;
                if (this.loadCount >= this.totalCount) {
                    this.loaded = true;
                    onComplete && onComplete();
                }
            };
            img.onerror = () => {
                console.warn(`Failed to load sprite: ${key}`);
                this.loadCount++;
                if (this.loadCount >= this.totalCount) {
                    this.loaded = true;
                    onComplete && onComplete();
                }
            };
            img.src = this.manifest[key];
        });
    },

    get(name) {
        return this.images[name] || null;
    },

    /**
     * Draw a frame from a spritesheet
     */
    drawFrame(ctx, spriteName, frame, x, y, cols, rows, scale = 1, rotation = 0) {
        const img = this.get(spriteName);
        if (!img) return;

        const frameWidth = img.width / cols;
        const frameHeight = img.height / rows;
        const col = frame % cols;
        const row = Math.floor(frame / cols);

        ctx.save();
        ctx.translate(x, y);
        if (rotation !== 0) {
            ctx.rotate(rotation * Math.PI / 180);
        }
        ctx.drawImage(
            img,
            col * frameWidth, row * frameHeight,
            frameWidth, frameHeight,
            -frameWidth * scale / 2, -frameHeight * scale / 2,
            frameWidth * scale, frameHeight * scale
        );
        ctx.restore();
    },

    /**
     * Get frame dimensions
     */
    getFrameSize(spriteName, cols, rows) {
        const img = this.get(spriteName);
        if (!img) return { width: 0, height: 0 };
        return {
            width: img.width / cols,
            height: img.height / rows
        };
    }
};

###EOF###

###[./js/bread.js]###

// ============================================
// BREAD ENTITY
// ============================================

class Bread {
    constructor(step) {
        this.step = step;
        this.u = Utils.stepToU(step);
        this.z = 0;
        this.travelTime = 0;
        this.alive = true;
        this.collected = false;
        this.missed = false;
        this.collisionChecked = false;
        
        // Animation
        this.animFrame = 0;
        this.animTime = 0;
        
        // Miss state
        this.shakeTime = 0;
        this.shakeOffset = { x: 0, y: 0 };
    }

    update(deltaTime, travelDuration, animSpeedMult) {
        if (!this.alive) return false;

        // Update travel progress
        this.travelTime += deltaTime;
        
        // Calculate raw progress (0 to 1)
        const rawProgress = this.travelTime / travelDuration;
        
        // Apply easing for z (accelerate toward player)
        this.z = Utils.easeIn(Math.min(rawProgress, 1), CONFIG.Z_EASE_POWER);

        // Update animation with speed multiplier
        const fps = this.missed ? CONFIG.BREAD_MISS_ANIM_FPS : CONFIG.BREAD_ANIM_FPS;
        const effectiveFps = fps * animSpeedMult;
        this.animTime += deltaTime;
        if (this.animTime >= 1 / effectiveFps) {
            this.animTime -= 1 / effectiveFps;
            this.animFrame = (this.animFrame + 1) % CONFIG.BREAD_TOTAL_FRAMES;
        }

        // Update shake if missed
        if (this.missed) {
            this.shakeTime += deltaTime * 1000;
            if (this.shakeTime < CONFIG.BREAD_SHAKE_TIME) {
                const intensity = CONFIG.BREAD_SHAKE_INTENSITY * (1 - this.shakeTime / CONFIG.BREAD_SHAKE_TIME);
                this.shakeOffset.x = (Math.random() - 0.5) * 2 * intensity;
                this.shakeOffset.y = (Math.random() - 0.5) * 2 * intensity;
            } else {
                this.alive = false;
            }
        }

        // Check if reached collision point (exactly once)
        if (this.z >= CONFIG.COLLISION_Z && !this.collected && !this.missed && !this.collisionChecked) {
            this.collisionChecked = true;
            return true; // Signal collision check needed
        }

        return false;
    }

    getScreenPosition(screen) {
        const x = Utils.uToScreenX(this.u, this.z, screen) + this.shakeOffset.x;
        const y = Utils.zToScreenY(this.z, screen) + this.shakeOffset.y;
        return { x, y };
    }

    getScale() {
        return Utils.getScaleAtZ(this.z);
    }

    collect() {
        this.collected = true;
        this.alive = false;
    }

    miss() {
        this.missed = true;
        this.shakeTime = 0;
    }

    draw(ctx, screen, healthState) {
        if (!this.alive) return;

        const pos = this.getScreenPosition(screen);
        const scale = this.getScale();

        // Determine sprite based on health state
        let spriteName;
        switch (healthState) {
            case 0: spriteName = 'bread-limbo'; break;
            case 2: spriteName = 'bread-hyper'; break;
            default: spriteName = 'bread-normal';
        }

        Sprites.drawFrame(
            ctx,
            spriteName,
            this.animFrame,
            pos.x, pos.y,
            CONFIG.BREAD_COLS, CONFIG.BREAD_ROWS,
            scale
        );
    }
}

const BreadManager = {
    breads: [],
    spawnTimer: 0,
    stagePatterns: [],
    currentPattern: [],
    patternIndex: 0,

    init() {
        this.breads = [];
        this.spawnTimer = 0;
        this.generatePattern();
    },

    generatePattern() {
        this.currentPattern = [];
        const patternLength = Utils.randomInt(20, 40);
        const patternType = Utils.randomInt(0, 3);
        
        switch (patternType) {
            case 0: // Sequential
                let pos = Utils.randomInt(1, CONFIG.NUM_STEPS - 2);
                let dir = Math.random() < 0.5 ? 1 : -1;
                for (let i = 0; i < patternLength; i++) {
                    this.currentPattern.push(pos);
                    pos += dir;
                    if (pos < 0 || pos >= CONFIG.NUM_STEPS) {
                        dir = -dir;
                        pos += dir * 2;
                    }
                }
                break;
                
            case 1: // Zigzag
                let col = Utils.randomInt(2, CONFIG.NUM_STEPS - 3);
                for (let i = 0; i < patternLength; i++) {
                    this.currentPattern.push(col);
                    col += (i % 2 === 0) ? 2 : -2;
                    col = Utils.clamp(col, 1, CONFIG.NUM_STEPS - 2);
                }
                break;
                
            case 2: // Clusters
                for (let i = 0; i < patternLength / 3; i++) {
                    const center = Utils.randomInt(2, CONFIG.NUM_STEPS - 3);
                    this.currentPattern.push(center - 1, center, center + 1);
                }
                break;
                
            default: // Random
                for (let i = 0; i < patternLength; i++) {
                    this.currentPattern.push(Utils.randomInt(1, CONFIG.NUM_STEPS - 2));
                }
        }
        
        this.patternIndex = 0;
    },

    getNextStep() {
        if (this.patternIndex >= this.currentPattern.length) {
            this.generatePattern();
        }
        return this.currentPattern[this.patternIndex++];
    },

    update(deltaTime, gameTime, travelDuration, spawnInterval, animSpeedMult) {
        // Spawn new bread
        this.spawnTimer += deltaTime;
        if (this.spawnTimer >= spawnInterval) {
            this.spawnTimer -= spawnInterval;
            const step = this.getNextStep();
            this.breads.push(new Bread(step));
        }

        // Update existing breads
        const collisions = [];
        for (let i = this.breads.length - 1; i >= 0; i--) {
            const bread = this.breads[i];
            const needsCollisionCheck = bread.update(deltaTime, travelDuration, animSpeedMult);
            
            if (needsCollisionCheck) {
                collisions.push(bread);
            }
            
            if (!bread.alive) {
                this.breads.splice(i, 1);
            }
        }

        return collisions;
    },

    draw(ctx, screen, healthState) {
        // Sort by z for proper depth ordering (far first)
        const sorted = [...this.breads].sort((a, b) => a.z - b.z);
        sorted.forEach(bread => bread.draw(ctx, screen, healthState));
    },

    clear() {
        this.breads = [];
        this.spawnTimer = 0;
        this.patternIndex = 0;
        this.currentPattern = [];
    }
};

###EOF###

###[./js/player.js]###

// ============================================
// PLAYER STATE & ANIMATION
// ============================================

const Player = {
    x: 0,
    targetX: 0,
    
    // Animation state
    state: 'run',
    animFrame: 0,
    animTime: 0,
    damageLoopCount: 0,
    damageLoopsCompleted: 0,
    
    // State flags
    isGameOver: false,
    
    init(screenWidth) {
        this.x = screenWidth / 2;
        this.targetX = this.x;
        this.state = 'run';
        this.animFrame = 0;
        this.animTime = 0;
        this.damageLoopCount = 0;
        this.damageLoopsCompleted = 0;
        this.isGameOver = false;
    },

    setTargetX(x) {
        this.targetX = x;
    },

    update(deltaTime) {
        // Smooth movement toward target
        const smoothing = 0.15;
        this.x += (this.targetX - this.x) * smoothing;

        // Update animation
        this.updateAnimation(deltaTime);
    },

    updateAnimation(deltaTime) {
        let fps, totalFrames;
        
        switch (this.state) {
            case 'run':
                fps = CONFIG.PLAYER_RUN_FPS;
                totalFrames = CONFIG.PLAYER_RUN_FRAMES;
                break;
            case 'damage-hold':
                fps = CONFIG.PLAYER_DAMAGE_HOLD_FPS;
                totalFrames = CONFIG.PLAYER_DAMAGE_HOLD_FRAMES;
                break;
            case 'damage-recover':
                fps = CONFIG.PLAYER_DAMAGE_RECOVER_FPS;
                totalFrames = CONFIG.PLAYER_DAMAGE_RECOVER_FRAMES;
                break;
            case 'defeat':
                fps = CONFIG.PLAYER_DEFEAT_KNEE_FPS;
                totalFrames = CONFIG.PLAYER_DEFEAT_KNEE_FRAMES;
                break;
            default:
                return;
        }

        this.animTime += deltaTime;
        const frameTime = 1 / fps;
        
        while (this.animTime >= frameTime) {
            this.animTime -= frameTime;
            this.animFrame++;

            // Handle animation completion/looping
            if (this.animFrame >= totalFrames) {
                switch (this.state) {
                    case 'run':
                        this.animFrame = 0;
                        break;
                    case 'damage-hold':
                        this.damageLoopsCompleted++;
                        if (this.damageLoopsCompleted >= CONFIG.PLAYER_DAMAGE_HOLD_LOOPS) {
                            // Switch to recover animation
                            this.state = 'damage-recover';
                            this.animFrame = 0;
                            this.animTime = 0;
                            this.damageLoopsCompleted = 0;
                        } else {
                            this.animFrame = 0;
                        }
                        break;
                    case 'damage-recover':
                        // Return to run
                        this.state = 'run';
                        this.animFrame = 0;
                        this.animTime = 0;
                        break;
                    case 'defeat':
                        this.animFrame = totalFrames - 1; // Hold on last frame
                        break;
                }
            }
        }
    },

    triggerDamage() {
        if (this.state === 'defeat') return;
        
        if (this.state === 'damage-hold') {
            // Reset loop counter if already in damage
            this.damageLoopsCompleted = 0;
        } else {
            // Start damage hold animation
            this.state = 'damage-hold';
            this.animFrame = 0;
            this.animTime = 0;
            this.damageLoopsCompleted = 0;
        }
    },

    triggerGameOver() {
        this.isGameOver = true;
        this.state = 'defeat';
        this.animFrame = 0;
        this.animTime = 0;
    },

    getStep(screen) {
        return Utils.screenXToStep(this.x, screen);
    },

    isInOOB(screen) {
        return Utils.isInOOBZone(this.x, screen);
    },

    draw(ctx, screen, healthState, discoX, discoY) {
        let spriteName, offsetX, offsetY, cols, rows;
        
        switch (this.state) {
            case 'run':
                spriteName = 'player-run';
                offsetX = CONFIG.PLAYER_RUN_OFFSET_X;
                offsetY = CONFIG.PLAYER_RUN_OFFSET_Y;
                cols = 8; rows = 1;
                break;
            case 'damage-hold':
                spriteName = 'player-damage-hold';
                offsetX = CONFIG.PLAYER_DAMAGE_HOLD_OFFSET_X;
                offsetY = CONFIG.PLAYER_DAMAGE_HOLD_OFFSET_Y;
                cols = 8; rows = 1;
                break;
            case 'damage-recover':
                spriteName = 'player-damage-recover';
                offsetX = CONFIG.PLAYER_DAMAGE_RECOVER_OFFSET_X;
                offsetY = CONFIG.PLAYER_DAMAGE_RECOVER_OFFSET_Y;
                cols = 8; rows = 1;
                break;
            case 'defeat':
                spriteName = 'player-defeat-knee';
                offsetX = CONFIG.PLAYER_DEFEAT_KNEE_OFFSET_X;
                offsetY = CONFIG.PLAYER_DEFEAT_KNEE_OFFSET_Y;
                cols = 11; rows = 1;
                break;
        }

        const x = discoX + CONFIG.PLAYER_UNIVERSAL_OFFSET_X + offsetX;
        const y = discoY + screen.height * CONFIG.PLAYER_UNIVERSAL_OFFSET_Y_PCT + offsetY;

        Sprites.drawFrame(
            ctx,
            spriteName,
            this.animFrame,
            x, y,
            cols, rows,
            CONFIG.PLAYER_SCALE
        );
    }
};

###EOF###

###[./js/utils.js]###

// ============================================
// UTILITY FUNCTIONS
// ============================================

const Utils = {
    /**
     * Linear interpolation
     */
    lerp(a, b, t) {
        return a + (b - a) * t;
    },

    /**
     * Clamp value between min and max
     */
    clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },

    /**
     * Ease-in function (power-based)
     */
    easeIn(t, power = 2) {
        return Math.pow(t, power);
    },

    /**
     * Ease-out function (power-based)
     */
    easeOut(t, power = 2) {
        return 1 - Math.pow(1 - t, power);
    },

    /**
     * Ease-in-out function
     */
    easeInOut(t, power = 2) {
        return t < 0.5 
            ? Math.pow(2, power - 1) * Math.pow(t, power)
            : 1 - Math.pow(-2 * t + 2, power) / 2;
    },

    /**
     * Get screen dimensions accounting for mobile address bar
     */
    getScreenDimensions() {
        const container = document.getElementById('gameContainer');
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
    },

    /**
     * Calculate play field boundaries
     */
    getPlayField() {
        const screen = this.getScreenDimensions();
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        
        return {
            left: marginX,
            right: screen.width - marginX,
            width: screen.width - 2 * marginX,
            screenWidth: screen.width,
            screenHeight: screen.height
        };
    },

    /**
     * Convert normalized u (0-1) to screen X at a given z depth
     */
    uToScreenX(u, z, screen) {
        // Top line (far)
        const topWidth = screen.width * CONFIG.TOP_LINE_WIDTH_PCT;
        const topLeft = (screen.width - topWidth) / 2;
        const topRight = topLeft + topWidth;
        const xTop = this.lerp(topLeft, topRight, u);

        // Bottom line (close)
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        const bottomLeft = marginX;
        const bottomRight = screen.width - marginX;
        const xBottom = this.lerp(bottomLeft, bottomRight, u);

        // Interpolate based on z
        return this.lerp(xTop, xBottom, z);
    },

    /**
     * Convert z to screen Y
     */
    zToScreenY(z, screen) {
        const topY = screen.height * CONFIG.TOP_LINE_Y_PCT;
        const bottomY = screen.height * CONFIG.BOTTOM_LINE_Y_PCT;
        return this.lerp(topY, bottomY, z);
    },

    /**
     * Get scale factor at given z depth
     */
    getScaleAtZ(z) {
        const t = Math.pow(z, CONFIG.SCALE_POWER);
        return this.lerp(CONFIG.SCALE_FAR, CONFIG.SCALE_NEAR, t);
    },

    /**
     * Convert step index to normalized u value
     */
    stepToU(step) {
        return (step + 0.5) / CONFIG.NUM_STEPS;
    },

    /**
     * Convert screen X to step index
     */
    screenXToStep(x, screen) {
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        const playWidth = screen.width - 2 * marginX;
        const relativeX = x - marginX;
        const u = relativeX / playWidth;
        return Math.floor(Utils.clamp(u, 0, 0.9999) * CONFIG.NUM_STEPS);
    },

    /**
     * Check if screen X is in OOB zone
     */
    isInOOBZone(x, screen) {
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        return x < marginX || x > screen.width - marginX;
    },

    /**
     * Convert continuous player X to normalized u (0-1)
     */
    screenXToU(x, screen) {
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        const playWidth = screen.width - 2 * marginX;
        const relativeX = x - marginX;
        return Utils.clamp(relativeX / playWidth, 0, 1);
    },

    /**
     * Get step boundaries for collision line
     */
    getStepBoundaries(screen) {
        const marginX = screen.width * CONFIG.OOB_MARGIN_PERCENT;
        const playWidth = screen.width - 2 * marginX;
        const stepWidth = playWidth / CONFIG.NUM_STEPS;
        const y = screen.height * CONFIG.BOTTOM_LINE_Y_PCT;
        
        const steps = [];
        for (let i = 0; i < CONFIG.NUM_STEPS; i++) {
            steps.push({
                left: marginX + i * stepWidth,
                right: marginX + (i + 1) * stepWidth,
                center: marginX + (i + 0.5) * stepWidth,
                y: y
            });
        }
        return steps;
    },

    /**
     * Random number in range
     */
    random(min, max) {
        return min + Math.random() * (max - min);
    },

    /**
     * Random integer in range (inclusive)
     */
    randomInt(min, max) {
        return Math.floor(this.random(min, max + 1));
    },

    /**
     * Pick random element from array
     */
    randomPick(array) {
        return array[Math.floor(Math.random() * array.length)];
    },

    /**
     * HSL to RGB conversion
     */
    hslToRgb(h, s, l) {
        h = h / 360;
        s = s / 100;
        l = l / 100;
        
        let r, g, b;
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
};

###EOF###

###[./js/particles.js]###

// ============================================
// PARTICLE SYSTEM
// ============================================

class Particle {
    constructor(x, y, color, isRainbow = false) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.isRainbow = isRainbow;
        this.hue = Math.random() * 360;
        this.size = Utils.random(CONFIG.PARTICLE_SIZE_MIN, CONFIG.PARTICLE_SIZE_MAX);
        
        const angle = Utils.random(0, Math.PI * 2);
        const speed = Utils.random(CONFIG.PARTICLE_SPEED_MIN, CONFIG.PARTICLE_SPEED_MAX);
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        
        this.lifetime = CONFIG.PARTICLE_LIFETIME;
        this.age = 0;
        this.alive = true;
        this.currentSize = this.size;
    }

    update(deltaTime) {
        this.age += deltaTime;
        if (this.age >= this.lifetime) {
            this.alive = false;
            return;
        }

        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.vy += 300 * deltaTime; // Gravity
        
        // Shrink over time
        const progress = this.age / this.lifetime;
        this.currentSize = this.size * (1 - progress);
        
        // Update rainbow hue
        if (this.isRainbow) {
            this.hue = (this.hue + 720 * deltaTime) % 360;
        }
    }

    draw(ctx) {
        if (!this.alive) return;

        const alpha = 1 - (this.age / this.lifetime);
        ctx.save();
        ctx.globalAlpha = alpha;
        
        if (this.isRainbow) {
            const rgb = Utils.hslToRgb(this.hue, 100, 60);
            ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            
            // Add glow for rainbow particles
            ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
            ctx.shadowBlur = 10;
        } else {
            ctx.fillStyle = this.color;
        }
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

const ParticleSystem = {
    particles: [],

    spawn(x, y, count = CONFIG.PARTICLE_COUNT, isRainbow = false) {
        const colors = isRainbow ? CONFIG.PARTICLE_RAINBOW_COLORS : CONFIG.PARTICLE_COLORS;
        for (let i = 0; i < count; i++) {
            const color = Utils.randomPick(colors);
            this.particles.push(new Particle(x, y, color, isRainbow));
        }
    },

    update(deltaTime) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update(deltaTime);
            if (!this.particles[i].alive) {
                this.particles.splice(i, 1);
            }
        }
    },

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    },

    clear() {
        this.particles = [];
    }
};

###EOF###

###[./js/floatingtext.js]###

// ============================================
// FLOATING TEXT SYSTEM
// ============================================

class FloatingText {
    constructor(x, y, text, config) {
        this.x = x;
        this.startY = y;
        this.y = y;
        this.text = text;
        this.color = config.color || '#FFFFFF';
        this.fontSize = config.fontSize || 32;
        this.riseDistance = config.riseDistance || 80;
        this.duration = config.duration || 800;
        this.isRainbow = config.isRainbow || false;
        this.rainbowSpeed = config.rainbowSpeed || 360;
        
        this.age = 0;
        this.alive = true;
        this.hue = Math.random() * 360;
    }

    update(deltaTime) {
        this.age += deltaTime * 1000;
        
        if (this.age >= this.duration) {
            this.alive = false;
            return;
        }

        const progress = this.age / this.duration;
        this.y = this.startY - (this.riseDistance * progress);
        
        if (this.isRainbow) {
            this.hue = (this.hue + this.rainbowSpeed * deltaTime) % 360;
        }
    }

    draw(ctx) {
        if (!this.alive) return;

        const progress = this.age / this.duration;
        const alpha = 1 - Utils.easeIn(progress, 2);

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = `bold ${this.fontSize}px Arial Black, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if (this.isRainbow) {
            // Rainbow effect with glow
            const rgb = Utils.hslToRgb(this.hue, 100, 60);
            ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
            ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
            ctx.shadowBlur = 15;
            
            // Draw multiple times for extra glow
            ctx.fillText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
        } else {
            // Normal text with outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillStyle = this.color;
            ctx.fillText(this.text, this.x, this.y);
        }
        
        ctx.restore();
    }
}

const FloatingTextSystem = {
    texts: [],

    spawnDamageText(x, y) {
        const text = Utils.randomPick(CONFIG.FLOAT_TEXT_DAMAGE_TEXTS);
        this.texts.push(new FloatingText(x, y + CONFIG.FLOAT_TEXT_DAMAGE_OFFSET_Y, text, {
            color: CONFIG.FLOAT_TEXT_DAMAGE_COLOR,
            fontSize: CONFIG.FLOAT_TEXT_DAMAGE_FONT_SIZE,
            riseDistance: CONFIG.FLOAT_TEXT_DAMAGE_RISE_DISTANCE,
            duration: CONFIG.FLOAT_TEXT_DAMAGE_DURATION,
            isRainbow: false
        }));
    },

    spawnMaxHealthText(x, y) {
        const text = Utils.randomPick(CONFIG.FLOAT_TEXT_MAX_TEXTS);
        this.texts.push(new FloatingText(x, y + CONFIG.FLOAT_TEXT_MAX_OFFSET_Y, text, {
            fontSize: CONFIG.FLOAT_TEXT_MAX_FONT_SIZE,
            riseDistance: CONFIG.FLOAT_TEXT_MAX_RISE_DISTANCE,
            duration: CONFIG.FLOAT_TEXT_MAX_DURATION,
            isRainbow: true,
            rainbowSpeed: CONFIG.FLOAT_TEXT_MAX_RAINBOW_SPEED
        }));
    },

    update(deltaTime) {
        for (let i = this.texts.length - 1; i >= 0; i--) {
            this.texts[i].update(deltaTime);
            if (!this.texts[i].alive) {
                this.texts.splice(i, 1);
            }
        }
    },

    draw(ctx) {
        this.texts.forEach(t => t.draw(ctx));
    },

    clear() {
        this.texts = [];
    }
};

###EOF###

###[./js/input.js]###

// ============================================
// INPUT HANDLING (Mouse, Touch, Tilt)
// ============================================

const Input = {
    currentX: 0,
    isActive: false,
    canvas: null,
    tiltEnabled: false,
    maxTilt: 30, // max degrees left/right mapped to screen edges

    init(canvas) {
        this.canvas = canvas;
        this.reset(canvas.width);

        // Mouse events
        canvas.addEventListener('mousemove', (e) => this.handleMove(e.clientX));
        canvas.addEventListener('mouseenter', () => this.isActive = true);
        canvas.addEventListener('mouseleave', () => this.isActive = false);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.isActive = true;
            if (e.touches.length > 0) {
                this.handleMove(e.touches[0].clientX);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                this.handleMove(e.touches[0].clientX);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            // keep last position
        }, { passive: false });
    },

    handleMove(clientX) {
        const rect = this.canvas.getBoundingClientRect();
        this.currentX = clientX - rect.left;
        this.isActive = true;
    },

    getX() {
        return this.currentX;
    },

    reset(screenWidth) {
        this.currentX = screenWidth / 2;
        this.isActive = false;
    },

    // Called from UI's "Enable Tilt" button
    enableTilt() {
        if (this.tiltEnabled) return;
        this.tiltEnabled = true;

        window.addEventListener('deviceorientation', (e) => {
            if (!this.tiltEnabled) return;

            // gamma = left/right tilt, map -maxTilt..maxTilt to canvas width
            const gamma = e.gamma || 0; 
            const rect = this.canvas.getBoundingClientRect();
            const clamped = Math.max(-this.maxTilt, Math.min(this.maxTilt, gamma));
            const pct = (clamped + this.maxTilt) / (this.maxTilt * 2);
            this.currentX = pct * rect.width;
        }, true);
    }
};


###EOF###

